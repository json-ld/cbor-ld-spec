<!DOCTYPE html>
<html lang="en">
<head>
<title>CBOR-LD 1.0</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
<script src="common/common.js" class="remove" defer></script>
<script src="common/jsonld.js" class="remove"></script>
<script class="remove">
  var respecConfig = {
      // extend the bibliography entries
      localBiblio:            jsonld.localBiblio,

      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus:             "CG-DRAFT",
      // if you wish the publication date to be other than today, set this
      //publishDate:          "2018-09-11",
      copyrightStart:         "2020",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName:              "cbor-ld",
      subtitle:               "A CBOR-based Serialization for Linked Data",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // prevVersion:          "https://www.w3.org/TR/2020/PR-json-ld11-20200507/",
      // previousPublishDate:  "2020-05-07",
      // previousMaturity:     "PR",
      // prevRecURI:            "https://www.w3.org/TR/2014/REC-json-ld-20140116/",
      // errata:               "https://w3c.github.io/json-ld-syntax/errata/",
      github:               {
        repoURL:"https://github.com/json-ld/cbor-ld-spec/",
        branch: "main"
      },

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI:             "https://json-ld.github.io/cbor-ld-spec/",
      // testSuiteURI:           "https://digitalbazaar.github.io/json-ld-api/tests/",
      // implementationReportURI:"https://digitalbazaar.github.io/json-ld-api/reports/",
      // crEnd:                  "2020-04-03",
      // prEnd:                  "2020-06-18",

      includePermalinks:      true,
      doJsonLd:               true,
      pluralize:              true,

      // Cross-reference definitions
      xref: ["json-ld11", "json-ld11-api", "json-ld11-framing"],

      // if you want to have extra CSS, append them to this list
      // it is recommended that the respec.css stylesheet be kept
      // extraCSS:             [],

      // editors, add as many as you like
      // only "name" is required
      editors:  [
        { name:       "Manu Sporny",
          url:        "http://manu.sporny.org/",
          company:    "Digital Bazaar",
          companyURL: "https://digitalbazaar.com/"},
        { name:       "Dave Longley",
          url:        "https://digitalbazaar.com/author/dlongley/",
          w3cid:      "48025",
          company:    "Digital Bazaar",
          companyURL: "https://digitalbazaar.com/"}
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:  [
        { name:       "Manu Sporny",
          url:        "http://manu.sporny.org/",
          company:    "Digital Bazaar",
          companyURL: "https://digitalbazaar.com/"},
        { name:       "Dave Longley",
          url:        "https://digitalbazaar.com/author/dlongley/",
          w3cid:      "48025",
          company:    "Digital Bazaar",
          companyURL: "https://digitalbazaar.com/"}
      ],

      // name of the WG
      //wg:           "JSON-LD Community Group",
      group: "cg/json-ld",

      // URI of the public WG page
      //wgURI:        "https://www.w3.org/2018/json-ld-wg/",

      // name (with the @w3c.org) of the public mailing to which comments are due
      //wgPublicList: "public-linked-json",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/107714/status",
      processVersion: 2018,
      maxTocLevel: 4,
      //alternateFormats: [ {uri: "json-ld11.epub", label: "EPUB"} ]
  };
</script>
<style>
  .hl-bold { font-weight: bold; color: #0a3; }
  .comment { color: #999; }
  table, thead, tr, td { padding: 5px; border-width: 1px; border-spacing: 0px; border-style: solid; border-collapse: collapse; }
  table.example {width: 100%;}
  .example > pre.context:before {
    content: "Context";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.frame:before {
    content: "Frame";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.input:before {
    content: "Input";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.result:before {
    content: "Result";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .example > pre.turtle:before {
    content: "Turtle";
    float: right;
    font: x-large Arial, sans-serif;
    color: gray;
    border: solid thin black;
    padding: 0.2em;
  }
  .highlight.changed, .show-changes {
    background-color: lime;
  }
  .show-changes.selected:before {
    content: "de-highlight";
  }
  .show-changes:before {
    content: "highlight";
  }
  aside.example {
    overflow-y: hidden;
  }
  /* example tab selection */
  .ds-selector-tabs {
    padding-bottom: 2em;
  }
  .ds-selector-tabs .selectors {
    padding: 0;
    border-bottom: 1px solid #ccc;
    height: 28px;
  }
  .ds-selector-tabs .selectors button {
    display: inline-block;
    min-width: 54px;
    text-align: center;
    font-size: 11px;
    font-weight: bold;
    height: 27px;
    padding: 0 8px;
    line-height: 27px;
    transition: all,0.218s;
    border-top-right-radius: 2px;
    border-top-left-radius: 2px;
    color: #666;
    border: 1px solid transparent;
  }
  .ds-selector-tabs .selectors button:first-child {
    margin-left: 2px;
  }
  .ds-selector-tabs .selectors button.selected {
    color: #202020 !important;
    border: 1px solid #ccc;
    border-bottom: 1px solid #fff !important;
  }
  .ds-selector-tabs .selectors button:hover {
    background-color: transparent;
    color: #202020;
    cursor: pointer;
  }
  .ds-selector-tabs pre:not(.preserve), .ds-selector-tabs table:not(.preserve) {
    display: none;
  }
  .ds-selector-tabs pre.selected, .ds-selector-tabs table.selected {
    display: block;
  }
  a.playground {
    display: inline-block;
    width: 150px;
    border: 1px solid transparent;
    border-top-right-radius: 2px;
    border-top-left-radius: 2px;
    background-color: rgb(192, 192, 192);
    text-decoration: none;
    font-size: 13px;
    margin-bottom: 10px;
  }
  a[href].playground {
    padding: 4px 0 3px 8px;
    border-bottom: none;
    text-decoration: none;
    color: #666;
  }
</style>
</head>

<body>
<section id="abstract">
  <p>
CBOR is a compact binary data serialization and messaging format. This
specification defines CBOR-LD 1.0, a CBOR-based format to serialize Linked Data.
The encoding is designed to leverage the existing JSON-LD ecosystem, which is
deployed on hundreds of millions of systems today, to provide a compact
serialization format for those seeking efficient encoding schemes for Linked
Data. By utilizing semantic compression schemes, compression ratios in excess of
60% better than generalized compression schemes are possible. This format is
primarily intended to be a way to use Linked Data in storage and bandwidth
constrained programming environments, to build interoperable semantic wire-level
protocols, and to efficiently store Linked Data in CBOR-based storage engines.
  </p>
</section>

<section id="sotd">
  <p>This document is experimental.</p>

  <p>There is a
<a href="https://github.com/digitalbazaar/cborld/">reference implementation</a> that is
capable of demonstrating the features described in this document.
  </p>
</section>

<section class="informative">
  <h1>Introduction</h1>
  <p>
CBOR is a compact binary data serialization and messaging format. This
specification defines CBOR-LD 1.0, a CBOR-based format to serialize Linked Data.
The encoding is designed to leverage the existing JSON-LD ecosystem, which is
deployed on hundreds of millions of systems today, to provide a compact
serialization format for those seeking efficient encoding schemes for Linked
Data. By utilizing semantic compression schemes, compression ratios in excess of
60% better than generalized compression schemes are possible. This format is
primarily intended to be a way to use Linked Data in storage and bandwidth
constrained programming environments, to build interoperable semantic wire-level
protocols, and to efficiently store Linked Data in CBOR-based storage engines.
  </p>

  <section class="informative">
    <h2>How to Read this Document</h2>

    <p>This document is a detailed specification for a serialization of Linked
      Data in CBOR. The document is primarily intended for the following audiences:</p>

    <ul>
      <li>Software developers who want to encode Linked Data in a variety of
        programming languages that can use CBOR</li>
      <li>Software developers who want to convert existing JSON-LD to CBOR-LD</li>
      <li>Software developers who want to understand the design decisions and
        language syntax for CBOR-LD</li>
      <li>Software developers who want to implement processors and APIs for
        CBOR-LD</li>
      <li>Software developers who want to generate or consume Linked Data,
        an RDF graph, or an RDF Dataset in a CBOR syntax</li>
    </ul>

    <section id="conformance"></section>

  </section>

  <section class="informative">
    <h2>Contributing</h2>

    <p>There are a number of ways that one may participate in the development of
      this specification:</p>

    <ul>
      <li>Technical discussion typically occurs on the working group mailing list:
        <a href="https://lists.w3.org/Archives/Public/public-linked-json/">public-linked-json@w3.org</a></li>

      <li>The working group uses <a href="http://irc.w3.org/?channels=json-ld">#json-ld</a>
        IRC channel is available for real-time discussion on <a href="http://irc.w3.org">irc.w3.org</a>.</li>

      <li>The <a href="https://webchat.freenode.net/?channels=json-ld">#json-ld</a>
        IRC channel is also available for real-time discussion on irc.freenode.net.</li>
    </ul>
  </section>

  <!--section class="informative">
    <h2>Typographical conventions</h2>
    <div data-include="common/typographical-conventions.html"></div>
  </section>

  <section class="informative">
    <h2>Terminology</h2>

    <p>This document uses the following terms as defined in external specifications
      and defines terms specific to JSON-LD.</p>

    <div data-include="common/terms.html"
         data-oninclude="restrictReferences">
    </div>
  </section-->

  <section class="informative">
    <h2>Design Goals and Rationale</h2>

    <p>CBOR-LD satisfies the following design goals:</p>

    <dl>
      <dt>Simplicity</dt>
      <dd>
Implementations should be simple to implement given an existing JSON-LD
implementation.
      </dd>
      <dt>Efficient Storage</dt>
      <dd>
The encoding process should generate an aggressively compact Linked Data binary
format.
      </dd>
      <dt>Generalized Algorithm</dt>
      <dd>
The encoding algorithm must be generalized.
      </dd>
      <dt>Semantic Compression</dt>
      <dd>
The encoding format should maximize compression of Linked Data URLs (terms and
values). Focusing here ensures that the algorithms can achieve compression
ratios better than generalized compression algorithms.
      </dd>
      <dt>Raw Binary</dt>
      <dd>
Base-encoded binary values, and other compressible data types, should be
translated to their raw binary forms from base-encoded formats when possible
without sacrificing generality.
      </dd>
    </dl>

    <p>
Similarly, the following are non-goals.
    </p>

    <ul>
      <li>
Theoretical purity.
      </li>
      <li>
Creating new compaction/expansion algorithms specifically for CBOR-LD.
      </li>
      <li>
Large centralized registries for every term on the planet.
      </li>
      <li>
Data formats that require large spec changes or complex implementations to
roundtrip from JSON-LD to CBOR-LD and back.
      </li>
    </ul>

    <p>
The following minefields have been identified while working on this
specification:
    </p>

    <ul>
      <li>
While it is widely believed that hashing is fast, it's slower than string
comparison over a small set of strings. This is true because in order to hash,
you must consume the entire string. If you are performing string comparisons,
you can abort the second the byte-for-byte comparison fails. That is, when
processing two values, string comparison can abort processing and hashing
cannot. While most globally collision-resistant hashes are 256-bits, 32 byte
values are large and we can do better in many cases without sacrificing
collision resistance (which hashing algorithms like blake2b-8 cannot do).
      </li>
      <li>
Anything that requires you to pre-process the JSON-LD data is a non-starter --
it's expensive, and that means that you are encoding semantics in the data.
While this can lead to better compression in some cases, it increases the
complexity of the processors without providing an acceptable return on
investment.
      </li>
      <li>
Scoped contexts are the most challenging aspect of a more generalized solution.
The deeper the algorithm has to understand scoping, the more combinatorial the
problem becomes and thus the more possible compression values there are, which
harms compression size. The trick is to leverage the determinism in the existing
JSON-LD Processing algorithms and take shortcuts only when it won't affect
JSON-LD processing.
      </li>
    </ul>

  </section>
</section>

  <section class="informative">
    <h1>Basic Concept</h1>

    <p>
The general CBOR-LD encoding algorithm takes a JSON-LD Document and does
the following:
    </p>

    <ul>
      <li>
Determine if JSON-LD can be compressed (@context values in JSON-LD document that
reference contexts via URLs - embedded context values cannot be compressed)
      </li>
      <li>
Process a JSON-LD Context, building a CBOR-LD term codec map -- a list
of all terms that can be compressed (and whether or not their values can be
compressed). Sort the list. Associate byte values with each term starting at 0
and counting up.
      </li>
      <li>
Encoding the JSON-LD Document as CBOR-LD consists of replacing every key with
the byte value associated with the term. For every value that is `"@type":
"@id"`, replace the value with the byte value associated with the term.
      </li>
      <li>
Decoding the CBOR-LD Bytes as JSON-LD consists of replacing every CBOR key with
the associated value in the term codec map. For every value that is
`"@type": "@id"`, replace the value with the byte value associated with the
term.
      </li>
    </ul>
  </section>

  <section class="normative">
    <h1>CBOR Tags for CBOR-LD</h1>
    <p>
The first step in decoding a CBOR-LD payload is to recreate the term codec
map that was used to encode it by processing the contexts in the payload. However,
the contexts needed to create the term codec map can have their URLs encoded as integers
by CBOR-LD. If a CBOR-LD payload contains context URLs compressed in such a way, the
consumer of the CBOR-LD needs to know what compression tables (maps from JSON-LD terms to integers)
were used to compress the context URLs during creation to be able to reconstruct the term codec
map. The following sections define the exact mechanism by which this can be accomplished, allowing 
an arbitrary CBOR-LD consumer to decompress any CBOR-LD payload that conforms to this specification.
    </p>
    <p>
To this end, we have registered the range of CBOR tags 1536-1791** (0x0600-0x06FF) to be used for CBOR-LD,
where data that includes tag value is used to lookup what compression table(s) are needed
to decompress the CBOR-LD context URLs.
    </p>
    <p class="issue">
This exact range of tag values has not yet been officially registered with
<a href="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml">the IANA CBOR
Tag Registry</a>. The exact range is subject to change.
    </p>
    <section>
      <h2>CBOR-LD Varint</h2>
      <p>
To enable unbounded extension on possible use cases for CBOR-LD that require different
compression table material for consumption while working within a fixed number of
CBOR tag values, we define the following.
      </p>
      <p>
Implementers MUST interpret the last byte of the two-byte CBOR tag value on a CBOR-LD payload
as the beginning of a varint. If the CBOR tag is in the range `0x0600`â€“`0x067F`, the last byte of
the CBOR tag is a one-byte varint, and the tagged item MUST be a map containing the encoded
JSON-LD. If the CBOR tag is `0x0680` or greater, the tagged item MUST be an array containing
two elements. The first item in the array MUST be a major type 2 byte string containing the
rest of the varint, and the second item in the array MUST be a map containing the
encoded JSON-LD. See Algorithm <a
href="#get-cbor-ld-varint-structure-algorithm"></a> for
more information.
      </p>
      <p>
The value of this varint is then used to lookup a <b>CBOR-LD Varint Registry Entry</b> in the
<b>CBOR-LD Varint Registry</b>.
      </p>
    </section>
    <section>
      <h2>CBOR-LD Varint Registry</h2>
      <p>
The <b>CBOR-LD Registry</b> is a global list that provides
consumers of CBOR-LD payloads the information they need to reconstruct the term codec map
required for decompression. A <b>CBOR-LD Varint Registry Entry</b> contains the following:
        <ol>
          <li>
Registry Entry ID: a positive integer.
          </li>
          <li>
Use Case: what type of CBOR-LD payload this entry is used for.
          </li>
          <li>
`typeTables`: an array containing what `Type Tables` are to be used for this
type of payload.
          </li>
          <li>
`processingModel`: what processing model is used for this registry entry. A processing model
specifies how auto-generated CBOR-LD values are created from JSON-LD contexts as well as what
type encoders are used alongside the `Type Tables` (e.g. how to partially compress an 
`xsd:dateTime` value that does not appear in `Type Table`). The default processing model,
which will be defined later in this specification, will be used unless otherwise specified
in the Registry Entry.
          </li>
          <li>
Provisional: a yes/no flag indicating whether the entry is provisional. Provisional entries
may change or be removed.
          </li>
        </ol>
      </p>
      <p>
The `typeTables` associated with a <b>CBOR-LD Varint Registry Entry</b> MUST be an array of
or JSON objects. The only exception is the string "callerProvidedTable", which may appear in this array,
denoting that for this use case, a `Type Table` is required which is not globally
defined.
      </p>
      <p></p>
Dereferencing one of these URLs MUST result in a JSON object with the following properties:
      <ol>
        <li>
`type`: a JSON-LD type.
        </li>
        <li>
`table`: a JSON object that maps values of the above type to integers.
        </li>
      </ol>
      <p>
If a JSON object is present in the `typeTables` array, it MUST be in the above format.
      </p>
      <section>
        <h3>Registry</h3>
      </section>
      <p>
The following is the current CBOR-LD registry:
      </p>
      <table class="simple">
        <thead>
          <tr>
            <th>Registry Entry Id</th>
            <th>Use Case</th>
            <th>typeTables</th>
            <th>Processing Model</th>
            <th>Provisional</th>
          </tr>
        </thead>
        <tbody>
          <tr>
          <td>0</td>
          <td>Uncompressed CBORLD</td>
          <td>None</td>
          <td>DEFAULT</td>
          <td>No</td>
          </tr>
          <tr>
            <td>1</td>
            <td>Compressed CBORLD, default use case.</td>
            <td>DEFAULT</td>
            <td>DEFAULT</td>
            <td>No</td>
          </tr>
          <tr>
            <td>100</td>
            <td><a href='https://w3c-ccg.github.io/vc-barcodes/'>Verifiable Credential Barcodes Specification Test Vectors</a></td>
            <td>
[
  {
    type: "context",
    table:
    {
      "https://www.w3.org/ns/credentials/v2": 32768,
      "https://w3id.org/vc-barcodes/v1": 32769,
      "https://w3id.org/utopia/v2": 32770
    }
  },
  {
    type: "https://w3id.org/security#cryptosuiteString",
    table: 
    {
      "ecdsa-rdfc-2019": 1,
      "ecdsa-sd-2023": 2,
      "eddsa-rdfc-2022": 3,
      "ecdsa-xi-2023": 4
    }
  }
]
            </td>
            <td>DEFAULT</td>
            <td>Yes</td>
          </tr>
          <tr>
            <td>10001</td>
            <td>Provisional California DMV Credentials</td>
            <td>
[
  {
    type: "context",
    table:
    {
      "https://www.w3.org/ns/credentials/v2": 1,
      "https://w3id.org/vc-barcodes/v1": 2,
      "https://w3id.org/vc-dpp/v1rc1": 3,
      "https://w3id.org/vdl/v1": 4
    }
  },
  {
    type: "https://w3id.org/security#cryptosuiteString",
    table: 
    {
      "ecdsa-rdfc-2019": 1
    }
  },
  {
    type: "url",
    table: 
    {
      "did:key:zDnaeW9VZZs7NH1ykvS5EMFmdodu2wj4dPcrV3DzTAadrXJee": 1,
      "did:key:zDnaeW9VZZs7NH1ykvS5EMFmdodu2wj4dPcrV3DzTAadrXJee#zDnaeW9VZZs7NH1ykvS5EMFmdodu2wj4dPcrV3DzTAadrXJee": 2,
      "https://dmv.ca.gov/statuses/12345/status-lists": 3
    }
  }
]
            </td>
            <td>DEFAULT</td>
            <td>Yes</td>
          </tr>
          <tr>
            <td>10002</td>
            <td>Provisional First Responder SAP Credentials</td>
            <td>
[
  {
    type: "context",
    table:
    {
      "https://www.w3.org/ns/credentials/v2": 1,
      "https://w3id.org/vc-barcodes/v1": 2,
      "https://w3id.org/first-responder/sap/v1rc1": 3,
    }
  },
  {
    type: "https://w3id.org/security#cryptosuiteString",
    table: 
    {
      "ecdsa-rdfc-2019": 1
    }
  },
  {
    type: "url",
    table: 
    {
      "did:key:zDnaeW9VZZs7NH1ykvS5EMFmdodu2wj4dPcrV3DzTAadrXJee": 1,
      "did:key:zDnaeW9VZZs7NH1ykvS5EMFmdodu2wj4dPcrV3DzTAadrXJee#zDnaeW9VZZs7NH1ykvS5EMFmdodu2wj4dPcrV3DzTAadrXJee": 2,
      "https://caloes.ca.gov/statuses/12345/status-lists": 3
    }
  }
]
            </td>
            <td>DEFAULT</td>
            <td>Yes</td>
          </tr>
        </tbody>
      </table>

    </section>
  </section>
  <section class="normative">
    <h1>Algorithms</h1>
In this section we specify the algorithms required to convert JSON-LD to CBOR-LD
and vice versa. We first provide the context processing algorithms, which are required
for both decompression and compression, then provide the mode-specific algorithms.
    <section>
      <h2>Encoding and Decoding</h2>
      <section>
        <h3>JSON-LD to CBOR-LD Compression Algorithm</h3>
        <p>
This algorithm takes a map `typeTable`, an integer `registryEntryId`, and a JSON-LD
document or array of JSON-LD documents `jsonldDocuments` as input and returns an array
of hexadecimal strings `cborldDocuments` as output.
        </p>
        <ol>
          <li>
TODO: tag processing
          </li>
          <li>
Set `state` to an empty map.
          </li>
          <li>
Set `state.strategy` to "compression".
          </li>
          <li>
Set `state` to the result of passing `state` to
<a href="#initialize-conversion-algorithm"></a>.
          </li>
          <li>
Set `outputMaps` to the result of passing `state` and `jsonldDocument`
as `inputDocument` to <a href="#convert-document-algorithm"></a>.
          </li>
        </ol>
      </section>
      <section>
        <h3>CBOR-LD to JSON-LD Decompression Algorithm</h3>
      </section>
    </section>
    <section>
      <h2>Converter</h2>
      <section>
        <h3>Initialize Conversion Algorithm</h3>
        <p>
This algorithm takes and returns a map `state`.
        </p>
        <ol>
          <li>
If `state.strategy` is set to "compression", set `state` to the result of
<a href="#initialize-compression-algorithm"></a>.
          </li>
          <li>
Else if `state.strategy` is set to "decompression", set `state` to the result of
<a href="#initialize-decompression-algorithm"></a>.
          </li>
          <li>
Set `state` to the result of passing `state` to
<a href="#initialize-context-loader-algorithm"></a>.
          </li>
          <li>
Set `state.initialActiveContext` to the result of passing empty maps `termMap` and
`previousActiveContext` to <a href="#initialize-active-context-algorithm"></a>.            
          </li>
          <li>
Return `state`.
          </li>
        </ol>
      </section>
      <section>
        <h3>Convert Document Algorithm</h3>
        <p>
This algorithm takes a map `state` and a map or array of
maps `inputDocuments` and returns a map containing a map `state` and a map or
array of maps `outputMaps`.
        </p>
        <ol>
          <li>
If `inputDocuments` is  an array, set `inputs` to `inputDocuments`. Otherwise, set `inputs`
to `[inputDocuments]`.
          </li>
          <li>
Set `outputMaps` to an empty array.
          </li>
          <li>
For `input` in `inputs`:
            <ol>
              <li>
Set `output` to an empty map.
              </li>
              <li>
Set `result` to the result of passing `state`, `input`, `output`, and
`state.initialActiveContext` as `activeContext` to
<a href="#general-conversion-algorithm"></a>.
              </li>
              <li>
Add `result.output` to `outputMaps`.
              </li>
              <li>
Set `state` to `result.state`.
              </li>
            </ol>
          </li>
          <li>
If `inputDocuments` is an array, return `outputMaps`. Otherwise, return the
first element of `outputMaps`.
          </li>
        </ol>
      </section>
      <section>
        <h3>General Conversion Algorithm</h3>
        <p>
This algorithm takes maps `input`, `output`, `state`, and `activeContext`
as input and returns a map containing maps `state` and `output`.
        </p>
        <ol>
          <li>
If `state.strategy` is set to "compression", set `activeContext` to 
`result.activeContext` and `state` to `result.state` of `result` resulting from  
<a href="#convert-contexts-for-compression-algorithm"></a>, passing `state`,
`activeContext`, `input`, and `output`. 
          </li>
          <li>
Otherwise, set `activeContext` to
`result.activeContext` and `state` to `result.state` of `result` resulting from 
<a href="#convert-contexts-for-decompression-algorithm"></a>, passing `state`,
`activeContext`, `input`, and `output`.
          </li>
          <li>
If `state.strategy` is set to "compression", set `state` to `result.state` and
`objectTypes` to `result.objectTypes` for `result` resulting from
<a href="#get-object-types-for-compression-algorithm"></a>, passing `state`,
`activeContext`, `input`, and `output`.
          </li>
          <li>
Otherwise, set `state` to `result.state` and `objectTypes` to `result.objectTypes`
for `result` resulting from <a href="#get-object-types-for-decompression-algorithm"></a>,
passing `state`, `activeContext`, `input`, and `output`.
          </li>
          <li>
Set `activeContext` to the result of passing `activeContext` and `objectTypes` to
<a href="#apply-type-scoped-contexts-algorithm"></a>.
          </li>
          <li>
If `state.strategy` is set to "compression", set `state` to `result.state` and
`termEntries` to `result.termEntries` for `result` resulting from
<a href="#get-input-entries-for-compression-algorithm"></a>, passing `state`,
`input`, and `activeContext`.
          </li>
          <li>
Otherwise, set `state` to `result.state` and `termEntries` to `result.termEntries`
for `result` resulting from <a href="#get-input-entries-for-decompression-algorithm"></a>,
passing `state`, `input`, and `activeContext`.
          </li>
          <li>
For `[termInfo, value]` in `termEntries`:
            <ol>
              <li>
Set `term` to `termInfo.term`.
              </li>
              <li>
Set `valueActiveContext` to the result of passing `activeContext` and `term` to
<a href="#apply-property-scoped-contexts-algorithm"></a>.
              </li>
              <li>
Set `plural` to the value of `termInfo.plural` and `termType` to the value of `@type`
in `termInfo.def`.
              </li>
              <li>
If `plural` is set to `true`, set `values` to the value of `value`. Otherwise, set `values` to
an array containing the value of `value` as a single element.
              </li>
              <li>
Set `outputs` to an empty array.
              </li>
              <li>
For `unconvertedValue` in `values`:
                <ol>
                  <li>
Set `result` to the result of <a href="#convert-value-algorithm"></a>,
passing `state`, `termType`, `unconvertedValue` as `value`, and `valueActiveContext`
as `activeContext`.
                  </li>
                  <li>
Set `state` to `result.state` and add `result.output` to `outputs`.
                  </li>
                </ol>
              </li>
              <li>
If `plural` is set to `true`, set `outputValues` to `outputs`. Otherwise, set `outputValues`
to the first element of `outputs`.
              </li>
              <li>
If `state.strategy` is set to "compression", set the value of `termInfo.termId` to map to
`outputValues` in `output`. Otherwise, set the value of `termInfo.term` to map to `outputValues`
in `output`.
              </li>
            </ol>
          </li>
          <li>
Set `result` to be an empty map.
          </li>
          <li>
Set `result.state` to `state` and `result.output` to `output`.
          </li>
          <li>
Return `result`.
          </li>
        </ol>
      </section>
      <section>
        <h3>Convert Value Algorithm</h3>
      </section>
      <section>
        <h3>Compressor</h3>
        <section>
          <h4>Initialize Compression Algorithm</h4>
          <p>
This algorithm takes and returns a map `state`.
          </p>
        </section>
        <section>
          <h4>Convert Contexts for Compression Algorithm</h4>
          <p>
This algorithm takes maps `state`, `input`, and `output`, and returns a map `output`.
          </p>
          <ol>
            <li>

            </li>
          </ol>
        </section>
        <section>
          <h4>Convert Value for Compression Algorithm</h4>
          <p>
This algorithm takes and returns a map `state`.
          </p>
        </section>
        <section>
          <h4>Get Input Entries for Compression Algorithm</h4>
          <p>
This algorithm takes and returns a map `state`.
          </p>
        </section>
        <section>
          <h4>Get Object Types for Compression Algorithm</h4>
          <p>
This algorithm takes and returns a map `state`.
          </p>
        </section>
      </section>
      <section>
        <h3>Decompressor</h3>
        <section>
          <h4>Initialize Decompression Algorithm</h4>
          <p>
This algorithm takes and returns a map `state`.
          </p>
        </section>
        <section>
          <h4>Convert Contexts for Decompression Algorithm</h4>
          <p>
This algorithm takes and returns a map `state`.
          </p>
        </section>
        <section>
          <h4>Convert Value for Decompression Algorithm</h4>
          <p>
This algorithm takes and returns a map `state`.
          </p>
        </section>
        <section>
          <h4>Get Input Entries for Decompression Algorithm</h4>
          <p>
This algorithm takes and returns a map `state`.
          </p>
        </section>
        <section>
          <h4>Get Object Types for Decompression Algorithm</h4>
          <p>
This algorithm takes and returns a map `state`.
          </p>
        </section>
      </section>
    </section>

    <section>
      <h2>Active Context</h2>
        <p>
TODO: description
        </p>
        <section>
          <h3>Initialize Active Context Algorithm</h3>
          <p>
This algorithm takes maps `previousActiveContext` and `termMap`
and returns a map `activeContext`. It updates the active context
in use and finds all aliases for `'@type'`.
          </p>
          <ol>
            <li>
Set `activeContext` to a new map.
            </li>
            <li>
Set `activeContext.previousActiveContext` to `previousActiveContext`.
            </li>
            <li>
Set `activeContext.termMap` to `termMap`.
            </li>
            <li>
Set `activeContext.typeTerms` to the array `['@type']`.
            </li>
            <li>
For `[term, def]` in `termMap`:
              <ol>
                <li>
If `def['@id'] == '@type'`, add `term` to `activeContext.typeTerms`.
                </li>
              </ol>
            </li>
            <li>
Return `activeContext`.
            </li>
          </ol>
        </section>
        <section>
          <h3>Apply Embedded Contexts Algorithm</h3>
            <p>
This algorithm takes maps `state`, `activeContext` and `input` as input and
returns a map `result` containing maps `state` and `activeContext`.
            </p>
            <ol>
              <li>
Set `termMapUpdateResult` to the result of passing `state`, `activeContext.termMap` as
`activeTermMap`, and the value of '@context' in `input` as `contexts` to 
<a href="#update-term-map-algorithm"></a>.
              </li>
              <li>
Set `state` to `termMapUpdateResult.state`.
              </li>
              <li>
Set `termMap` to `termMapUpdateResult.activeTermMap`.
              </li>
              <li>
Set `newActiveContext` to the result of <a href="#initialize-active-context-algorithm"></a>,
passing `termMap` and `activeContext` as `previousActiveContext`.
              </li>
              <li>
Set `result` to be a new map, and set `result.activeContext` to `newActiveContext` and
`result.state` to `state`.
              </li>
              <li>
Return `result`. 
              </li>
            </ol>
        </section>
        <section>
          <h3>Apply Property Scoped Contexts Algorithm</h3>
          <p>
This algorithm takes maps `state`, `activeContext` and a string `term` as input and
returns a map `result` containing maps `state` and `activeContext`.
          </p>
          <ol>
            <li>
Set `revertedTermMap` to the result of <a href="#revert-term-map-algorithm"></a>,
passing `activeContext`.
            </li>
            <li>
Set `termDef` to the value of `term` in `activeContext.termMap`. Set `contexts` to the value of
"@context" in `termDef`.
            </li>
            <li>
Set `termMapUpdateResult` to the result of passing `state`, `revertedTermMap` as
`activeTermMap`, `true` as `propertyScope`, and `contexts` to 
<a href="#update-term-map-algorithm"></a>.
            </li>
            <li>
Set `state` to `termMapUpdateResult.state`.
            </li>
            <li>
Set `termMap` to `termMapUpdateResult.activeTermMap`.
            </li>
            <li>
Set `newActiveContext` to the result of <a href="#initialize-active-context-algorithm"></a>,
passing `termMap` and `activeContext` as `previousActiveContext`.
            </li>
            <li>
Set `result` to be a new map, and set `result.activeContext` to `newActiveContext` and
`result.state` to `state`.
            </li>
            <li>
Return `result`. 
            </li>
          </ol>
        </section>
        <section>
          <h3>Apply Type Scoped Contexts Algorithm</h3>
          <p>
This algorithm takes maps `state`, `activeContext` and a set `objectTypes` as input and
returns a map `result` containing maps `state` and `activeContext`.
          </p>
          <ol>
            <li>
Set `objectTypesSorted` to an empty array.
            </li>
            <li>
Lexicographically sort the elements of `objectTypes` and add the elements to
`objectTypesSorted` in order.
            </li>
            <li>
Set `newTermMap` to `activeContext.termMap`.
            </li>
            <li>
For `type` in `objectTypesSorted`:
              <ol>
                <li>
Set `typeDef` to the value of `type` in `newTermMap`. Set `contexts` to the value of
"@context" in `typeDef`.
                </li>
                <li>
Set `termMapUpdateResult` to the result of passing `state`, `newTermMap` as
`activeTermMap`, `contexts`, and `true` as `typeScope` to
<a href="#update-term-map-algorithm"></a>.
                </li>
                <li>
Set `state` to `termMapUpdateResult.state` and `newTermMap` to
`termMapUpdateResult.activeTermMap`.
                </li>
              </ol>
            </li>
            <li>
Set `newActiveContext` to the result of <a href="#initialize-active-context-algorithm"></a>,
passing `newTermMap` as `termMap` and `activeContext` as `previousActiveContext`.
            </li>
            <li>
Set `result` to be a new map, and set `result.activeContext` to `newActiveContext` and
`result.state` to `state`.
              </li>
              <li>
Return `result`. 
              </li>
          </ol>
        </section>
        <section>
          <h3>Update Term Map Algorithm</h3>
        </section>
        <section>
          <h3>Revert Term Map Algorithm</h3>
        </section>

    </section>    

    <section>
      <h2>Context Loader</h2>
      <p>
TODO: description
      </p>
      <section>
        <h3>Initialize Context Loader Algorithm</h3>
        <p>
This algorithm takes and returns a map `state`.
        </p>
        <ol>
          <li>
Set `state.contextMap` to a new map.
          </li>
          <li>
Set `state.nextTermId` to 100.
          </li>
          <li>
Set `state.termToId` to the following map of JSON-LD keywords to their associated
integer values:
            <pre class="nohighlight">
{
  '@context' => 0,
  '@type' => 2,
  '@id' => 4,
  '@value' => 6,
  '@direction' => 8,
  '@graph' => 10,
  '@included' => 12,
  '@index' => 14,
  '@json' => 16,
  '@language' => 18,
  '@list' => 20,
  '@nest' => 22,
  '@reverse' => 24,
  '@base' => 26,
  '@container' => 28,
  '@default' => 30,
  '@embed' => 32,
  '@explicit' => 34,
  '@none' => 36,
  '@omitDefault' => 38,
  '@prefix' => 40,
  '@preserve' => 42,
  '@protected' => 44,
  '@requireAll' => 46,
  '@set' => 48,
  '@version' => 50,
  '@vocab' => 52,
  '@propagate' => 54
}
            </pre>
          </li>
          <li>
If `state.strategy` is set to "decompression", set `state.idToTerm` to the reverse map
of `state.termToId` (i.e., a map from integers to JSON-LD keywords).
          </li>
          <li>
Return `state`.
          </li>
        </ol>
      </section>
      <section>
        <h3>Add Context Algorithm</h3>
      </section>
    </section>

    <section>
      <h2>Codecs</h2>
    </section>

    <section>
      <h2>CBOR Tag Processing</h2>
    </section>


    <section>
      <h2>-----OLD-------</h2>
      <h2>Context Processing</h2>
      <p>
The following algorithms specify how to process JSON-LD contexts to create the Term Codec Map
that is needed to compress or decompress to/from CBOR-LD. During compression and decompression, the 
<a href="top-level-term-codec-map-generation-algorithm"></a> is run once during setup, and the 
<a href="update-term-codec-map-with-type-scoped-context-algorithm"></a> and 
<a href="update-term-codec-map-with-property-scoped-context-algorithm"></a> are run on an as-needed basis.
      </p>
      <section>
        <h2>Top-level Term Codec Map Generation Algorithm</h2>
        <p>
This algorithm takes a map `typeTable` and an array of JSON-LD contexts `contexts` and 
returns a CBOR-LD term codec map that maps JSON-LD terms to their associated byte values
and value compression functions.
        </p>
        <ol>
          <li>Let `termToEncodedValue` be an ordered map.</li>
          <li>
For each value in `contextUrls`, dereference the JSON-LD contexts and process
every entry at the top level (i.e. ignoring type and property-scoped contexts).
            <ol>
              <li>
Set the entry key in `termToEncodedValue` to the JSON-LD term.
              </li>
              <li>
              </li>
            </ol>
          </li>
          <li>
Sort the keys in `termToEncodedValue` by value.
          </li>
          <li>
Set `nextTermId` to 100.
          </li>
          <li>
For every key in `termToEncodedValue`, set its value to `nextTermId` and increment `nextTermId` by 2.
          </li>
          <li>Return `termToEncodedValue`.</li>
        </ol>
      </section>
      <section>
        <h2>Update Term Codec Map with Type-Scoped Context Algorithm</h2>
      </section>
      <section>
        <h2>Update Term Codec Map with Property-Scoped Context Algorithm</h2>
      </section>

    </section>
    <section>
      <h2>Compression</h2>
      <section>
        <h2>JSON-LD to CBOR-LD Algorithm</h2>
  
        <p>
This algorithm takes JSON-LD objects `jsonldDocument` and `options` as well 
as an integer `registryEntryId` as input.
        </p>
  
        <ol>
          <li>
Let `result` be an empty CBOR-encoded byte array.</li>
          <li>
Set {`varintTagValue`, `varintBytesValue`} to the return value of the "Get CBOR-LD Varint Structure
Algorithm", passing `registryEntryId` as input.
          </li>
          <li>
If the "Get CBOR-LD Varint Structure Algorithm" resulted in an error, set `result` to the
return value of the "Generate Uncompressed CBOR-LD Algorithm".
          </li>
          <li>
Otherwise:
            <ol>
              <li>
Initialize `typeTables` to an empty map
              </li>
              <li>
For each entry in the `typeTables` array in the <b>CBOR-LD Varint Registry Entry</b> 
associated with `registryEntryId`, dereference the URL if necessary and add ${type}: ${table} from
the resulting document to `typeTables`. If "callerProvidedTable"
appears in `contextTables`, populate `typeTables` with `options.callerProvidedTable` as well.
              </li>
              <li>
Set `result` to the return value of the "Generate Compressed CBOR-LD
Algorithm" passing `typeTables` as `options.typeTable`, `varintTagValue` as `options.varintTagValue`,
and `varintBytesValue` as `options.varintBytesValue`.
              </li>
  
            </ol>
  
          <li>
Return `result`.
          </li>
        </ol>
      </section>
  
      <section>
        <h2>Uncompressed CBOR-LD Buffer Algorithm</h2>
  
        <p>
This algorithm takes a JSON-LD object `jsonldDocument`, integer `registryEntryId` and 
`options` as input.
        </p>
  
        <ol>
          <li>
Let `result` be an empty CBOR-encoded byte array.
          </li>
          <li>
Set the first two bytes (CBOR Tag) to 0x0600 (CBOR-LD - 0x06, Uncompressed -
0x00)
          </li>
          <li>
For every key-value in the map, generate the Uncompressed CBOR-LD
Buffer by converting it to the associated CBOR-LD header and value. For
complex values (maps, arrays), recursively convert the value to
something that will losslessly encode and decode back to JSON-LD.
          </li>
          <li>
Return the Uncompressed CBOR-LD Buffer.
          </li>
        </ol>
      </section>
      <section>
        <h2>Generate Compressed CBOR-LD Algorithm</h2>
        <p>
This algorithm takes a JSON-LD object `jsonldDocument` and `options` as input.
The `options` MUST contain:
        </p>
        <dl>
          <dt>`typeTable`</dt>
          <dd>
A map of JSON-LD types to maps. Each of these maps will map values of the associated
type to their encoded CBOR-LD values.
          </dd>
          <dt>`varintTagValue`</dt>
          <dd>
The CBOR tag value that will be used in the resulting payload.
          </dd>
          <dt>`varintBytesValue`</dt>
          <dd>
The bytes that will make up the rest of the CBOR-LD varint.
`options.varintBytesValue` MAY be `null`.  
          </dd>
        </dl>
  
        <ol>
          <li>
Let `result` be an empty CBOR-encoded byte array.
          </li>
          <li>
Set the first three bytes of `result` to `options.varintTagValue`.
          </li>
          <li>
If `options.varintBytesValue` is not `null`, set the next bytes of
`result` to `options.varintBytesValue`.
          </li>
          <li>
Initialize `termToEncodedValue` to the result of the 
<a href="#top-level-term-codec-map-generation-algorithm"></a>, passing `typeTable` as input.
          </li>
          <li>
For every entry `term`:`values` in `jsonldDocument`:
            <ol>
              <li>
If `term` has associated type information, apply the
<a href="#update-term-codec-map-with-type-scoped-context-algorithm"></a> to add relevant type-scoped contexts to
`termToEncodedValue`.
              </li>
              <li>
Apply the <a href="#update-term-codec-map-with-property-scoped-context-algorithm"></a> to update `termToEncodedValue` with
any property-scoped contexts.
              </li>
              <li>
For every `value` in `values`:
                <ol>
                  <li>
If `value` is null, add it to `result`.
                  </li>
                  <li>
If `value` is an array, create an output array, recursively process each element, and add the output array to `result`.
                  </li>
                  <li>
If `value` is an object, recurse starting at step 3 and populate `result` with the return value.
                  </li>
                  <li>
Otherwise, convert the value by checking value type and using value-specific codecs as well as `termToEncodedValue, and
add the output to `result`.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
Return `result`.
          </li>
        </ol>
      </section>
      <section>
        <h3>Get Context URLs Algorithm</h3>
        <ol>
          <li>
Let `result` be a ordered map.
          </li>
          <li>
Walk the JSON tree, for each JSON name-value pair:
            <ol>
              <li>
If the name is `@context`
                <ol>
                  <li>
Add all values that are referenced by a URL to `result` where the key in the map
is set to the JSON value associated with `@id`.
                  </li>
                </ol>
              </li>
              <li>
If a non-URL value is detected, throw an ERR_NON_URL_JSONLD_CONTEXT_DETECTED
error.
              </li>
            </ol>
          </li>
          <li>
Return `result`.
          </li>
        </ol>
      </section>
      <section>
        <h3>Get CBOR-LD Varint Structure Algorithm</h3>
This algorithm takes as input an integer `registryEntryId`.
        <ol>
          <li>
If `registryEntryId` is less than 128:
            <ol>
              <li>
Set `varintEncoded` to the byte encoding of `registryEntryId`.
              </li>
              <li>
Set `varintTagValue` to the result of appending `varintEncoded` to the end of the bytes
0xD906, and set `varintBytesValue` to `null`.
              </li>
            </ol>
          </li>
          <li>
Otherwise:
            <ol>
              <li>
Set `varintArray` to an array containing the varint representation of `registryEntryId`.
              </li>
              <li>
Set `varintTagValue` to `varintArray[0]` appended to the end of the bytes 0xD906.
              </li>
              <li>
Set `varintBytesValue` to a CBOR array containing the rest of `varintArray`.
              </li>
            </ol>
          </li>
          <li>
Return {varintTagValue, varintBytesValue}.
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h2>Decompression</h2>
      <section>
        <h2>CBOR-LD to JSON-LD Algorithm</h2>
  
        <p>
This algorithm takes a CBOR-LD object `cborldBytes` and JSON object `options` as input.
        </p>
  
        <ol>
          <li>
Set `registryEntryId` to the result of passing `cborldBytes` to the 
<a
href="#get-cbor-ld-registry-entry-id-algorithm"></a>.
          </li>
          <li>
Set `typeTable` to an empty map.
          </li>
          <li>
For each entry in the typeTables array in the CBOR-LD Varint Registry Entry associated with
`registryEntryId`, dereference the URL if necessary and add ${type}: ${table} from the resulting
document to `typeTable`. If "callerProvidedTable" appears in contextTables, populate `typeTables`
with `options.callerProvidedTable` as well.
          </li>
          <li>
Otherwise:
            <ol>
              <li>
Initialize `typeTables` to an empty map.
              </li>
              <li>
Set `result` to the return value of the <a
href="#generate-decompressed-json-ld-algorithm"></a>, passing `cborldBytes and `typeTable`.
              </li>
  
            </ol>
  
          <li>
Return `result`.
          </li>
        </ol>
      </section>
      <section>
        <h2>Get CBOR-LD Registry Entry ID Algorithm</h2>
        <p>
This algorithm takes a CBOR-LD payload `cborldBytes` as input and returns
the <b>Registry Entry Id</b> for the <b>CBOR-LD Registry Entry</b> that should be used to
decompress `cborldBytes`.
        </p>
        <ol>
          <li>
If the CBOR tag on `cborldBytes` is not in the range `0x0600-0x06FF`, throw an
ERR_NON_CBOR_LD_TAG error.
          </li>
          <li>
Otherwise if the CBOR tag on `cborldBytes` is in the range `0x0600-0x067F`, set `registryEntryId` to
the value of the last byte of the CBOR tag.          
          </li>
          <li>
Otherwise:
            <ol>
              <li>
If the last byte of the CBOR tag does not form the first byte of a valid varint, throw an
ERR_INVALID_VARINT_VALUE error.
              </li>
              <li>
Otherwise, set the value of `registryEntryId` to the value of the varint for which the first byte is the last
byte of the CBOR tag.
              </li>
            </ol>
            
          </li>
          <li>
Return `registryEntryId`.
          </li>
        </ol>
      </section>
      <section>
        <h2>
Generate Decompressed JSON-LD Algorithm
        </h2>
        <p>
This algorithm takes as input CBOR-LD payload `cborldBytes` and a map `typeTable` and returns a JSON-LD document.
        </p>
        <ol>
          <li>
Initialize `termToEncodedValue` to the result of the 
<a href="#top-level-term-codec-map-generation-algorithm"></a>, passing `typeTable` as input.
          </li>
          <li>
Let `result` be an empty JSON-LD document.
          </li>
          <li>
For every entry `term`:`values` in `cborldBytes`:
            <ol>
              <li>
If the key associated with the value of `term` in `termToEncodedValue` has associated type information, apply the
<a href="#update-term-codec-map-with-type-scoped-context-algorithm"></a> to add relevant type-scoped contexts to
`termToEncodedValue`.
              </li>
              <li>
Apply the <a href="#update-term-codec-map-with-property-scoped-context-algorithm"></a> to update `termToEncodedValue` with
any property-scoped contexts.
              </li>
              <li>
For every `value` in `values`:
                <ol>
                  <li>
If `value` is null, add it to `result`.
                  </li>
                  <li>
If `value` is an array, create an output array, recursively process each element, and add the output array to `result`.
                  </li>
                  <li>
If `value` is an object, recurse starting at step 3 and populate `result` with the return value.
                  </li>
                  <li>
Otherwise, convert the value by checking value type and using value-specific codecs as well as `termToEncodedValue`
and add the output to `result`.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
Return `result`.
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h2>Type and Value Codecs</h2>
    </section>
   
  </section>
  

  <section class="appendix">
    <h1>Term Codec Registry</h1>
    <p>
<b>**Note:</b> This term codec registry is deprecated and has been replaced by the CBOR-LD
Varint Registry.
    </p>
    <p>
The following is a registry of well-known term codecs.
These will be registered on a first-come first-serve basis.
    </p>

    <table class="simple">
      <thead>
        <tr>
          <th>Value</th>
          <th>Context URL</th>
          <th>Context Name</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>0x00 - 0x0F</code></td>
          <td><code>RESERVED</code></td>
          <td>Reserved for future use.</td>
        </tr>
        <tr>
          <td><code>0x10</code></td>
          <td><code>https://www.w3.org/ns/activitystreams</code></td>
          <td>ActivityStreams 2.0</td>
        </tr>
        <tr>
          <td><code>0x11</code></td>
          <td><code>https://www.w3.org/2018/credentials/v1</code></td>
          <td>Verifiable Credentials Data Model v1</td>
        </tr>
        <tr>
          <td><code>0x12</code></td>
          <td><code>https://www.w3.org/ns/did/v1</code></td>
          <td>Decentralized Identifiers (DID) Core Spec v1</td>
        </tr>
        <tr>
          <td><code>0x13</code></td>
          <td><code>https://w3id.org/security/suites/ed25519-2018/v1</code></td>
          <td>Ed25519Signature2018 Suite</td>
        </tr>
        <tr>
          <td><code>0x14</code></td>
          <td><code>https://w3id.org/security/suites/ed25519-2020/v1</code></td>
          <td>Ed25519Signature2020 Suite</td>
        </tr>
        <tr>
          <td><code>0x15</code></td>
          <td><code>https://w3id.org/cit/v1</code></td>
          <td>Concealed Id Token</td>
        </tr>
        <tr>
          <td><code>0x16</code></td>
          <td><code>https://w3id.org/age/v1</code></td>
          <td>Age Verification</td>
        </tr>
        <tr>
          <td><code>0x17</code></td>
          <td><code>https://w3id.org/security/suites/x25519-2020/v1</code></td>
          <td>X25519KeyAgreementKey2020 Suite</td>
        </tr>
        <tr>
          <td><code>0x18</code></td>
          <td><code>https://w3id.org/veres-one/v1</code></td>
          <td>Veres One DID Method</td>
        </tr>
        <tr>
          <td><code>0x19</code></td>
          <td><code>https://w3id.org/webkms/v1</code></td>
          <td>WebKMS (Key Management System)</td>
        </tr>
        <tr>
          <td><code>0x1A</code></td>
          <td><code>https://w3id.org/zcap/v1</code></td>
          <td>Authorization Capabilities (zCap)</td>
        </tr>
        <tr>
          <td><code>0x1B</code></td>
          <td><code>https://w3id.org/security/suites/hmac-2019/v1</code></td>
          <td>Sha256HmacKey2019 Crypto Suite</td>
        </tr>
        <tr>
          <td><code>0x1C</code></td>
          <td><code>https://w3id.org/security/suites/aes-2019/v1</code></td>
          <td>AesKeyWrappingKey2019 Crypto Suite</td>
        </tr>
        <tr>
          <td><code>0x1D</code></td>
          <td><code>https://w3id.org/vaccination/v1</code></td>
          <td>Vaccination Certificate Vocabulary v0.1</td>
        </tr>
        <tr>
          <td><code>0x1E</code></td>
          <td><code>https://w3id.org/vc-revocation-list-2020/v1</code></td>
          <td>Verifiable Credentials Revocation List 2020</td>
        </tr>
        <tr>
          <td><code>0x1F</code></td>
          <td><code>https://w3id.org/dcc/v1</code></td>
          <td>DCC (Decentralized Credentials Consortium) Core Context</td>
        </tr>
        <tr>
          <td><code>0x20</code></td>
          <td><code>https://w3id.org/vc/status-list/v1</code></td>
          <td>Verifiable Credentials Status List</td>
        </tr>
        <tr>
          <td><code>0x21</code></td>
          <td><code>https://www.w3.org/ns/credentials/v2</code></td>
          <td>Verifiable Credentials Data Model v2</td>
        </tr>
        <tr>
          <td><code>0x22 - 0x2F</code></td>
          <td></td>
          <td>Available for use.</td>
        </tr>
        <tr>
          <td><code>0x30</code></td>
          <td><code>https://w3id.org/security/data-integrity/v1</code></td>
          <td>Data Integrity v1.0</td>
        </tr>
        <tr>
          <td><code>0x31</code></td>
          <td><code>https://w3id.org/security/multikey/v1</code></td>
          <td>Multikey v1.0</td>
        </tr>
        <tr>
          <td><code>0x32</code></td>
          <td></td>
          <td>Reserved for future use.</td>
        </tr>
        <tr>
          <td><code>0x33</code></td>
          <td><code>https://w3id.org/security/data-integrity/v2</code></td>
          <td>Data Integrity v2.0</td>
        </tr>
        <tr>
          <!--
            This range was prior experimental use for Data Integrity
            cryptosuite identifiers. It is expected this range will be made
            available at some future point unless the values were determined
            to be in active use.
          -->
          <td><code>0x34 - 0x36</code></td>
          <td><code>RESERVED</code></td>
          <td>Reserved for future use.</td>
        </tr>
      </tbody>
    </table>
  </section>

</body>
</html>
